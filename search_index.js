var documenterSearchIndex = {"docs":
[{"location":"constrs.html#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"constrs.html#Index","page":"Constructors","title":"Index","text":"","category":"section"},{"location":"constrs.html","page":"Constructors","title":"Constructors","text":"Pages = [\"constrs.md\"]","category":"page"},{"location":"constrs.html#Functions","page":"Constructors","title":"Functions","text":"","category":"section"},{"location":"constrs.html","page":"Constructors","title":"Constructors","text":"HyGeneModel(context_labels::Vector{Symbol}, hypothesis_labels::Vector{Symbol},\n            n_trace_vec::Vector{<:Number}, A_c::Number=0.2, t_max::Integer=10,\n            n_features::Integer=15, focal_similarity::Float64=0.0, encoding_fidelity::Float64=0.75)\nContext(label::Symbol, description::String, n_features::Integer)\nMemoryTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\nObsTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\nLongTermMemory(trace_vec::Vector{<:Trace}, A_c::Float64)\nSemanticMemory(ltm::LongTermMemory)\nSetofContenders(contenders::Vector{<:MemoryTrace}, t_max::Integer)","category":"page"},{"location":"constrs.html#HyGene.HyGeneModel","page":"Constructors","title":"HyGene.HyGeneModel","text":"HyGeneModel(context_labels::Vector{Symbol}, hypothesis_labels::Vector{Symbol},\n            n_trace_vec::Vector{<:Number}, A_c::Number=0.2, t_max::Integer=10,\n            n_features::Integer=15, focal_similarity::Float64=0.0, encoding_fidelity::Float64=0.75)\nHyGeneModel(n_contexts::Integer, n_hypotheses::Integer, n_obs_per_proto::Integer,\n            A_c::Number=0.2, t_max::Integer=10, n_features::Integer=15,\n            focal_similarity::Float64=0.0, encoding_fidelity::Float64=0.75)\n\nConstructor functions for the HyGeneModel object class.\n\n\n\n\n\n","category":"type"},{"location":"constrs.html#HyGene.Context-Tuple{Symbol, String, Integer}","page":"Constructors","title":"HyGene.Context","text":"Context(label::Symbol, description::String, n_features::Integer)\n\nConstructor for a new Context object. Generates a feature vector with values sampled from [-1.0, 0.0, 1.0].\n\nArguments\n\nlabel::Symbol: Symbol indicating the overall type of Context. In simulations, similar Context structures will have the same label.\ndescription::String: Optional description to help differentiate Context objects with similar labels.\nn_features::Integer: Length of resulting feature vector.\n\nReturns\n\nContext object with randomly-generated feature vector of length n_features.\n\n\n\n\n\n","category":"method"},{"location":"constrs.html#HyGene.MemoryTrace-Tuple{Symbol, String, Vector{<:Information}}","page":"Constructors","title":"HyGene.MemoryTrace","text":"MemoryTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\n\nConstructor for a [MemoryTrace]@(def) object.\n\nArguments\n\nlabel::Symbol: Symbol indicating the unique type of observation/trace.\ndescription::String: Optional description to help differentiate traces with similar labels.\ninfo_vec::Vector{<:Information}: List of Information/Context objects to be written to the resulting MemoryTrace object.\n\nReturns\n\nMemoryTrace object.\n\n\n\n\n\n","category":"method"},{"location":"constrs.html#HyGene.ObsTrace-Tuple{Symbol, String, Vector{<:Information}}","page":"Constructors","title":"HyGene.ObsTrace","text":"ObsTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\n\nConstructor for a ObsTrace object.\n\nArguments\n\nlabel::Symbol: Symbol indicating the unique type of observation/trace.\ndescription::String: Optional description to help differentiate traces with similar labels.\ninfo_vec::Vector{<:Information}: List of Information/Context objects to be written to the resulting ObsTrace object.\n\nReturns\n\nObsTrace object.\n\n\n\n\n\n","category":"method"},{"location":"constrs.html#HyGene.LongTermMemory-Tuple{Vector{<:Trace}, Float64}","page":"Constructors","title":"HyGene.LongTermMemory","text":"LongTermMemory(trace_vec::Vector{<:Trace}, A_c::Float64)\n\nConstructor for a LongTermMemory object.\n\nArguments\n\ntrace_vec::Vector{<:Trace}: List of traces to be written to long-term memory.\nA_c::Float64: Activation threshold. Used during the echo_content and cond_echo_intensity operations.\n\nReturns\n\nLongTermMemory object.\n\n\n\n\n\n","category":"method"},{"location":"constrs.html#HyGene.SemanticMemory-Tuple{LongTermMemory}","page":"Constructors","title":"HyGene.SemanticMemory","text":"SemanticMemory(ltm::LongTermMemory)\nSemanticMemory(exemplars::Vector{<:Trace})\n\nConstructor for the SemanticMemory structure class. If there are only contents in long-term memory, then this operation will create averaged feature vectors. If prototypes are given, then SemanticMemory will be populated with those.\n\nArguments\n\nltm::LongTermMemory: Memory store from which exemplar traces are to be extracted.\n\nReturns\n\nSemanticMemory object.\n\n\n\n\n\n","category":"method"},{"location":"constrs.html#HyGene.SetofContenders-Tuple{Vector{<:MemoryTrace}, Integer}","page":"Constructors","title":"HyGene.SetofContenders","text":"SetofContenders(contenders::Vector{<:MemoryTrace}, t_max::Integer)\nSetofContenders(t_max::Integer)\n\nConstructor function for the SetofContenders object. SetofContenders objects are typically instantiated with no contents.\n\nArguments\n\ncontenders::Vector{<:MemoryTrace}: Vector of memory traces to populate the SoC.\nt_max::Integer: Maximum number of retrieval failures.\n\nReturns\n\nSetofContenders object.\n\n\n\n\n\n","category":"method"},{"location":"functs.html#General-Functions","page":"General Functions","title":"General Functions","text":"","category":"section"},{"location":"functs.html#Index","page":"General Functions","title":"Index","text":"","category":"section"},{"location":"functs.html","page":"General Functions","title":"General Functions","text":"Pages = [\"functs.md\"]","category":"page"},{"location":"functs.html#Functions","page":"General Functions","title":"Functions","text":"","category":"section"},{"location":"functs.html","page":"General Functions","title":"General Functions","text":"create_vec\ntrace_replication\ntrace_activation\ntrace_similarity\ntrace_decay!\nbounce_memory!\nclear_content!\nstandardize_trace!\necho_content\npopulate_soc!\ncond_echo_intensity\nsoc_posterior_prob","category":"page"},{"location":"functs.html#HyGene.create_vec","page":"General Functions","title":"HyGene.create_vec","text":"create_vec(n_values::Integer)\n\nReturns a vector of length n_values with numbers randomly chosen from [-1.0 0.0 1.0].\n\nArguments\n\nn_values::Integer: Number of features in resulting vector.\n\nExample\n\njulia> using Random; Random.seed!(1);\n\njulia> create_vec(5)\n5-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n  0.0\n  1.0\n\n\n\n\n\ncreate_vec(n_vecs::Integer, n_values::Integer)\n\nReturns an array of minivectors. The array is length n_vecs while each minivector has n_values  features randomly sampled from [-1.0 0.0 1.0].\n\nArguments\n\nn_vecs::Integer: Number of minivectors.\nn_values::Integer: Number of features in each mini-vector.\n\nExample\n\njulia> using Random; Random.seed!(1);\n\njulia> create_vec(2, 3)\n2-element Vector{Vector{Float64}}:\n [0.0, -1.0, -1.0]\n [0.0, 0.0, -1.0]\n\n\n\n\n\ncreate_vec(n_vecs::Integer, n_values::Integer, similarity::Number)\n\nReturns an array of length n_vecs with each minivector containing n_values features randomly sampled from [-1.0 0.0 1.0]. After an initial minivector is created, the subsequent vectors will replicate each value with probability similarity.\n\nArguments\n\nn_vecs::Integer: Number of minivectors.\nn_values::Integer: Number of features in each mini-vector.\nsimiarlity::Number: Degree of similarity between each mini-vector.\n\nExample\n\njulia> using Random; Random.seed!(1);\n\njulia> vecs = create_vec(4, 4, 0.5)\n4-element Vector{Vector{Float64}}:\n [0.0, -1.0, -1.0, 1.0]\n [0.0, -1.0, 1.0, 1.0]\n [0.0, -1.0, 1.0, 1.0]\n [0.0, 1.0, 0.0, 1.0]\n\njulia> vecs[1]'vecs[2] / length(vecs[1]) # dot product\n0.25\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.trace_replication","page":"General Functions","title":"HyGene.trace_replication","text":"trace_replication(trace::Vector{Number}, similarity::Number, decay::Bool=false)\n\nReturns a degraded replication of a given trace vector. The elements of the returned vector are chosen from the original with a probabiliy of similarity. Values not copied from the original vector are randomly samped from [-1.0 0.0 1.0] or assigned 0.0 if you are decaying the trace (decay==true).\n\nArguments\n\ntrace::Vector{Number}: Vector of integers to be duplicated.\nsimilarity::Number: Degree of similarity between the original trace and resulting vector.\ndecay::Bool: Indicates if the similarity argument should be treated as the degree of decay. If true, then similarity is inverted, i.e., subtraced from 1.\n\nExample\n\njulia> using Random; Random.seed!(1);\n\njulia> vector = [1.0, 1.0, 0.0, -1.0];\n\njulia> trace_replication(vector, 0.5)\n4-element Vector{Float64}:\n 1.0\n 1.0\n 0.0\n 0.0\n\n\n\n\n\ntrace_replication(trace::Information, similarity::Number, decay::Bool=false)\ntrace_replication(trace::Trace, similarity::Number, decay::Bool=false)\n\nReturns a degraded replication of a given object under the HypothesisGeneration`  hierarchy. The elements of the minivectors within the returned object are chosen  from the original minivectors with a probabiliy of similarity. Values not copied from the original vector are randomly samped from [-1.0 0.0 1.0]or  assigned 0.0 if you are decaying the trace (decay==true)\n\nThe following HypothesisGeneration types can be used as the Trace object:\n\nTrace\n├─ Information\n│  └─ Context\n├─ MemoryTrace\n└─ ObsTrace\n\nArguments\n\ntrace: Object of either Information or Trace to be replicated.\nsimilarity::Number: Degree of similarity between the original trace and resulting object.\ndecay::Bool: Indicates if the similarity argument should be treated as the degree of decay. If true, then similarity is inverted, i.e., subtraced from 1.\n\nExample\n\njulia> using Random; Random.seed!(1);\n\njulia> context = Context(:a, \"this is context a\", 5)\nContext\n  label: Symbol a\n  description: String \"this is context a\"\n  n_features: Integer 5\n  contents: Array{Float64}((5,)) [-1.0, 0.0, 1.0, 0.0, 1.0]\n  A_i: Float64 0.0\n\njulia> trace_replication(context, 0.5)\nContext\n  label: Symbol a\n  description: String \"this is context a\"\n  n_features: Integer 5\n  contents: Array{Float64}((5,)) [-1.0, 0.0, 1.0, 0.0, -1.0]\n  A_i: Float64 0.0\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.trace_activation","page":"General Functions","title":"HyGene.trace_activation","text":"trace_activation(probe::Vector, trace::Vector, exponent::Integer=3)\ntrace_activation(probe::HypothesisGeneration, trace::HypothesisGeneration, exponent::Integer=3)\n\nThe trace_similarity calculation accelerated by an exponent of degree exponent, usually 3. This is analogous to a cubed cosine similarity. See Eqs 1 and 2 in Thomas et al. (2008) [1].\n\nbeginequation\n    A_i = left( fracsum_j=1^n P_j T_ijsqrtsum_j=1^n P_j^2 sqrtsum_j=1^n T_ij^2 right) ^3\nendequation\n\nSee the trace_similarity documentation for the base operation.\n\nArguments\n\nprobe: An object to be compared to the trace.\ntrace: An object to be compared to the probe.\nexponent::Integer=3: Degree of acceleration to the S_i value.\n\nExample\n\njulia> using Random; Random.seed!(25);\n\njulia> context_a = Context(:a, \"this is context a\", 10);\n\njulia> context_b = trace_replication(deepcopy(context_a), 0.5);\n\njulia> trace_activation(context_a, context_b)\n0.216\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.trace_similarity","page":"General Functions","title":"HyGene.trace_similarity","text":"trace_similarity(probe::Vector{<:Number}, trace::Vector{<:Number})\n\nCalculates the similarity between a probe vector and a trace. Eq 1 in Thomas et al. (2008) [1]. Essentially a dot product.\n\nbeginequation\n    S_i = fracsum_j=1^n P_j T_ijsqrtsum_j=1^n P_j^2 sqrtsum_j=1^n T_ij^2\nendequation\n\nArguments\n\nprobe::Vector{<:Number}: A vector of integers to be compared to the trace.\ntrace::Vector{<:Number}: A vector of integers.\n\nExample\n\njulia> a = [1.0, -1.0, 0.0, 1.0];\n\njulia> b = [1.0, 0.0, 0.0, 1.0];\n\njulia> trace_similarity(a,b)\n0.6666666666666666\n\n[1]: Thomas, R. P., Dougherty, M. R., Sprenger, A. M., & Harbison, J. (2008). Diagnostic hypothesis generation and human judgment. Psychological Review, 115(1), 155-185. https://psycnet.apa.org/doi/10.1037/0033-295X.115.1.155\n\n\n\n\n\ntrace_similarity(probe::Information, trace::Information)\ntrace_similarity(probe::Trace, trace::Trace)\n\nCalculates the similarity between a probe HypothesisGeneration object and a trace object.  If there are multiple Context vectors in the probe and trace, it will recursively compute trace_similarity for each vector and apply it to the overall S_i value.\n\nbeginequation\n    S_i = fracsum_j=1^n P_j T_ijsqrtsum_j=1^n P_j^2 sqrtsum_j=1^n T_ij^2\nendequation\n\nThe following types are accepted as probe and trace objects:\n\nTrace\n├─ Information\n│  └─ Context\n├─ MemoryTrace\n└─ ObsTrace\n\nArguments\n\nprobe: An object of either Information or Trace to be compared to trace.\ntrace: An object of either Information or Trace.\n\nExample\n\njulia> using Random; Random.seed!(25);\n\njulia> context_a = Context(:a, \"this is context a\", 10);\n\njulia> context_b = trace_replication(context_a, 0.5);\n\njulia> trace_similarity(context_a, context_b)\n0.6\n\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.trace_decay!","page":"General Functions","title":"HyGene.trace_decay!","text":"trace_decay!(trace::Information, decay::Number)\ntrace_decay!(trace::Trace, decay::Number)\ntrace_decay!(store::MemoryStore, decay::Number)\n\nReturns a HypothesisGeneration object with constituent Information vectors of numbers that have been copied to the new object with probability 1 - decay.\n\nArguments\n\ntrace: An Information, Trace, or MemoryStore object with contents to be degraded.\ndecay::Number: The degree of decay to the trace elements.\n\nExample\n\njulia> using Random; Random.seed!(2);\n\njulia> context_a = Context(:a, \"this is context a\", 10);\n\njulia> context_b = deepcopy(context_a);\n\njulia> trace_decay!(context_b, 0.5);\n\njulia> trace_similarity(context_a, context_b)\n0.6\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.bounce_memory!","page":"General Functions","title":"HyGene.bounce_memory!","text":"bounce_memory!(observation::Trace, memory::MemoryStore)\n\nRuns the trace_activation command between the observation object and all objects in the memory object. Activation values A_i and then written back to the Information vectors in memory.\n\nThis operation is used in parallel with echo_content and SetofContenders functions.\n\nArguments\n\nobservation::Trace: Observation from the real world to be compared to memory.\nmemory::MemoryStore: Memory store that the observation is compared to.\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.clear_content!","page":"General Functions","title":"HyGene.clear_content!","text":"clear_content!(context::Information)\nclear_content!(trace::Trace)\n\nResets Information vectors and activation (A_i) values back to zeros. No other fields, such as description are affected. Mostly useful for running multiple  simulations.\n\nArguments\n\nAn Information or Trace object to be reset.\n\nExample\n\njulia> using Random; Random.seed!(10);\n\njulia> context_a = Context(:a, \"this is context a\", 4)\nContext\n  label: Symbol a\n  description: String \"this is context a\"\n  n_features: Int64 4\n  contents: Array{Float64}((4,)) [-1.0, -1.0, -1.0, -1.0]\n  A_i: Float64 0.0\n\njulia> clear_content!(context_a);\n\njulia> context_a\nContext\n  label: Symbol a\n  description: String \"this is context a\"\n  n_features: Int64 4\n  contents: Array{Float64}((4,)) [0.0, 0.0, 0.0, 0.0]\n  A_i: Float64 0.0\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.standardize_trace!","page":"General Functions","title":"HyGene.standardize_trace!","text":"standardize_trace!(trace::Trace)\n\nDivides elements of all Information objects by the largest abolute value across all objects, restricting values in the range of [-1.0, 1.0]. Helps resolve the ambiguous  recall problem in global memory models (Hintzman, 1986) [2].\n\nArguments\n\ntrace: a Trace object with unstandardized Context mini-vectors.\n\njulia> using Random; Random.seed!(5);\n\njulia> context_a = Context(:a, \"this is context a\", 5);\n\njulia> context_a.contents .*= rand(5)\n5-element Vector{Float64}:\n  0.4113527070924652\n  0.8090056332338996\n -0.4913697257138979\n  0.0\n  0.0\n\njulia> trace_a = MemoryTrace(:event_a, \"this is event a\", [context_a]);\n\njulia> standardize_trace!(trace_a);\n\njulia> trace_a.contents[1].contents\n5-element Vector{Float64}:\n  0.5084670491701446\n  1.0\n -0.6073749125203349\n  0.0\n  0.0\n\n[2]: Hintzman, D. L. (1986). \"Schema abstraction\" in a multiple-trace memory model. Psychological Review, 93(4), 411-428. https://psycnet.apa.org/doi/10.1037/0033-295X.93.4.411\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.echo_content","page":"General Functions","title":"HyGene.echo_content","text":"echo_content(observation::Trace, memory::MemoryStore, \n             conditional::Bool=true, standardize::Bool=true)\n\nComputes trace_activation between the observation object and all objects in the memory store. Information vectors that are above activation threshold memory.A_c are then multiplied against their conditional activation values A_i (if conditional==true) and then summed across columns. The result is the \"echo content\"  from a given memory store, i.e., a MemoryTrace object with float values in the Information objects. The standardize parameter controls whether the operation controls for Hintzman's (1986) [2] ambiguous recall problem.\n\nThe resulting conditional echo content is given by Eq 7 in Thomas et al. (2008) [1]:\n\nbeginequation\n    C_c = sum_i=1^K A_i T_ij\nendequation\n\nArguments\n\nobservation::Trace: Observation made in the real world, usually a copy of a prototype.\nmemory::MemoryStore: A MemoryStore object by which the observation is \"bounced\" off of.\nconditional::Bool=true: Flag that indicates whether or not the program should calculate conditional echo content. true by default.\nstandardized::Bool=true: Flat that indicates whether or not the echo content should be standardized.\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.populate_soc!","page":"General Functions","title":"HyGene.populate_soc!","text":"populate_soc!(echo::MemoryTrace, soc::SetofContenders, semantic::SemanticMemory)\npopulate_soc!(echo::MemoryTrace, model::HyGeneModel)\n\nThis operation compares a trace (echo) to contents in semantic memory (semantic)  and writes semantic traces with activation values above a dynamic threshold (soc.act_min) to the SetofContenders object. \n\nSemantic traces are randomly sampled, and those that are above threshold will get written  to the SetofContenders and the activation threshold (soc.act_min) will be set to that  trace's activation (trace.A_i). If a trace's activation value does not exceed the  threshold, then it will be considered a retrieval failure and will increment the failure count variable (t) by 1. \n\nThe function will continue to randomly sample traces with replacement until the maximum number of retrieval attempts (t_max) has been reached.\n\nArguments\n\necho::MemoryTrace: Echo content trace to be compared to SemanticMemory.\nsoc::SetofContenders: Working memory store holding the contenders.\nsemantic::SemanticMemory: SemanticMemory store with trace exemplars.\nmodel::HyGeneModel: A generic Model object with a SetofContenders and SemanticMemory store.\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.cond_echo_intensity","page":"General Functions","title":"HyGene.cond_echo_intensity","text":"cond_echo_intensity(probe::MemoryTrace, memory::MemoryStore, conditional::Bool=true)\n\nReturns the conditional echo intensity of a memory trace object (probe) against a memory store (memory). Echo intensity values are computed against the contents of the probe for each item in memory. All intensity values above a threshold A_c are then summed and divided by the number of  above-threshold activations to produce I_c. If conditional is set to false, the function will return the sum of all intensity values divided by the number of items with activations above zero.\n\nAs per Eq. 5 in Thomas et al. (2008) [1]:\n\nbeginequation\n    I_c = fracsum I_A_i geq A_cK\nendequation\n\nArguments\n\nprobe: A Trace object to be compared to the memory store.\nmemory: A MemoryStore object with traces used to generate echo intensity.\nconditional::Bool=true: Flag to indicate whether the function should return conditional echo intensity. If false, then it will only return echo intensity and not conditional echo intensity.\n\n\n\n\n\n","category":"function"},{"location":"functs.html#HyGene.soc_posterior_prob","page":"General Functions","title":"HyGene.soc_posterior_prob","text":"soc_posterior_prob(soc, memory)\nsoc_posterior_prob(model)\n\nReturns a vector of posterior probabilities for all leading contenders in the SetofContenders. This is accomplished by computing conditional echo intensity values for all contenders against LongTermMemory and dividing them by the sum.\n\nAs per Eq. 8 in Thomas et al. (2008) [1]:\n\nbeginequation\n    P(H_i  D_obs) = fracI_C_isum_i=1^w I_C_i\nendequation\n\n\n\n\n\n","category":"function"},{"location":"structs.html#Structures","page":"Structures","title":"Structures","text":"","category":"section"},{"location":"structs.html#Index","page":"Structures","title":"Index","text":"","category":"section"},{"location":"structs.html","page":"Structures","title":"Structures","text":"Pages = [\"structs.md\"]","category":"page"},{"location":"structs.html#Abstract-Types","page":"Structures","title":"Abstract Types","text":"","category":"section"},{"location":"structs.html","page":"Structures","title":"Structures","text":"HypothesisGeneration\nModel\nMemoryStore\nTrace\nInformation","category":"page"},{"location":"structs.html#HyGene.HypothesisGeneration","page":"Structures","title":"HyGene.HypothesisGeneration","text":"HypothesisGeneration <: ContinuousUnivariateDistribution\n\nAn abstract type representing all structures related to HyGene simulations.  Mostly useful when using custom samplers, such as with Turing.jl, but also for preventing excessive function re-definition for different sub-types/structures.\n\nType Hierarchy\n\nHypothesisGeneration\n├─ MemoryStore\n│  ├─ LongTermMemory\n│  ├─ SemanticMemory\n│  └─ SetofContenders\n├─ Model\n│  └─ HyGeneModel\n└─ Trace\n   ├─ Information\n   │  └─ Context\n   ├─ MemoryTrace\n   └─ ObsTrace\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.Model","page":"Structures","title":"HyGene.Model","text":"Model <: HypothesisGeneration\n\nAn abstract type representing large simulation objects. The base code only includes one Model type (HyGeneModel), but users can create new objects for bespoke simulations.\n\nSubtypes\n\nHyGeneModel\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.MemoryStore","page":"Structures","title":"HyGene.MemoryStore","text":"MemoryStore <: HypothesisGeneration\n\nAn abstract type representing all memory stores.\n\nSubtypes\n\nLongTermMemory\nSemanticMemory\nSetofContenders\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.Trace","page":"Structures","title":"HyGene.Trace","text":"Trace <: MemoryStore\n\nAn abstract type representing chunks of information held in MemoryStore objects.\n\nSubtypes\n\nMemoryTrace\nObsTrace\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.Information","page":"Structures","title":"HyGene.Information","text":"Information <: Trace\n\nAn abstract type representing information held within chuncks in MemoryStore objects. There is only one subtype in this abstract class, but more can be created for bespoke simulations.\n\nSubtypes\n\nContext\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Model-Objects","page":"Structures","title":"Model Objects","text":"","category":"section"},{"location":"structs.html","page":"Structures","title":"Structures","text":"HyGeneModel","category":"page"},{"location":"structs.html#HyGene.HyGeneModel","page":"Structures","title":"HyGene.HyGeneModel","text":"HyGeneModel <: Model\n\nObject holding HypothesisGeneration simulation parameters, variables, and outcomes. The top-level operations that govern the HyGeneModel object are located in sim_controllers.jl.\n\nParameters\n\nA_c::Float64: Activation threshold in LongTermMemory.\nt_max::Integer: Maximum number of retrieval failures during SetofContenders operations.\ndecay::Float64: Degree of trace decay for LongTermMemory contents.\nfocal_similarity::Float64: Degree of similarity between the focal and alternative hypotheses.\nencoding_fidelity::Float64: Degree of change between an observation in the environment and a new MemoryTrace object.\nn_features::Integer: Length of context mini-vectors. 10 is recommended.\nn_unique_contexts::Integer: Number of unique Context types.\nn_unique_events::Integer: Number of unique MemoryTrace types in LongTermMemory and length of SemanticMemory store contents.\nn_obs_per_event::Any: Number of unqiue observations per unique MemoryTrace types in LongTermMemory.\ncontexts::Vector{Symbol}: List of labels of unique types of Context objects.\nhypotheses::Vector{Symbol}: List of labels of unique types of MemoryTrace objects.\nlen_ltm::Integer: Number of items in the LongTermMemory store. Should be n_unique_events * n_obs_per_event.\nlen_sm::Integer: Number of items in the SemanticMemory store. Should be n_unique_events.\nprototypes::Vector{<:Trace}: List of hypothesis exemplars.\nlong_term_memory::LongTermMemory: A single LongTermMemory object.\nsemantic_memory::SemanticMemory: A single SemanticMemory object.\nworking_memory::SetofContenders: A single SetofContenders object.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Mutable-Structures","page":"Structures","title":"Mutable Structures","text":"","category":"section"},{"location":"structs.html","page":"Structures","title":"Structures","text":"Context\nMemoryTrace\nObsTrace\nLongTermMemory\nSemanticMemory\nSetofContenders","category":"page"},{"location":"structs.html#HyGene.Context","page":"Structures","title":"HyGene.Context","text":"Context <: Information\n\nContainer used to hold information about a single \"context\", generally defined. Context structures are mutable and hold one numeric vector. They are considered to be the lowest level of information in the HypothesisGeneration environment.\n\nParameters\n\nlabel::Symbol: Symbol indicating the overall type of Context. In simulations, similar Context structures will have the same label.\ndescription::String: Optional description to help differentiate Context objects with similar labels.\nn_features::Integer: Length of feature vector.\ncontents::AbstractArray: A single array of length n_features.\nA_i::Float64: Optional value reflecting activation of the context. Typically unused during simulations.\n\nConstructor\n\nContext(label::Symbol, description::String, n_features::Integer)\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.MemoryTrace","page":"Structures","title":"HyGene.MemoryTrace","text":"MemoryTrace <: Trace\n\nContainer for objects that populate MemoryStore objects. They consist of 1 or more Context objects. These structures are analogous to information and memories that can potentially degrade across time. LongTermMemory stores typically contain multiple permutations of specific MemoryTrace objects while SemanticMemory holds single MemoryTrace objects for each type of observation. All parameters of the MemoryTrace object are mutable.\n\nParameters\n\nlabel::Symbol: Symbol indicating the unique type of observation/trace.\ndescription::String: Optional description to help differentiate traces with similar labels.\nn_contexts::Integer: Number of unique types of Context objects. This is determined by finding unique label values across all Context objects.\ncontexts::Vector{Symbol}: List of unique types of Context objects.\ncontents::Vector{<:Information}: Contents of the memory store, i.e., 1 or more Context objects.\nA_i::Float64: Activation value. Intitially set to 0.0 and then updated using the bounce_memory! function.\n\nConstructor\n\nMemoryTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.ObsTrace","page":"Structures","title":"HyGene.ObsTrace","text":"ObsTrace <: Trace\n\nStructurally similar to the MemoryTrace object type, but represents an observation made in the \"real world\" that is then compared to a MemoryStore object. Typically unneeded, but can be  useful for operations in parametric functions that differentiate memory traces and traces derived from outward observations.\n\nParameters\n\nlabel::Symbol: Symbol indicating the unique type of observation/trace.\ndescription::String: Optional description to help differentiate traces with similar labels.\nn_contexts::Integer: Number of unique types of Context objects. This is determined by finding unique label values across all Context objects.\ncontexts::Vector{Symbol}: List of unique types of Context objects.\ncontents::Vector{<:Information}: Contents of the memory store, i.e., 1 or more Context objects.\nA_i::Float64: Activation value. Typically unused.\n\nConstructor\n\nObsTrace(label::Symbol, description::String, info_vec::Vector{<:Information})\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.LongTermMemory","page":"Structures","title":"HyGene.LongTermMemory","text":"LongTermMemory <: MemoryStore\n\nA long-term memory store for Trace objects. Contents in LongTermMemory are potentially subject  to degradation (trace_decay!). LongTermMemory is key in echo content calculations and posterior probability estimates resulting from the SoC. Items in this store are used to create exemplars in SemanticMemory.\n\nParameters\n\nn_items::Integer: The number of Trace items in storage.\nA_c::Float64: Activation threshold for conditional retrieval/probability. Used during the echo_content and cond_echo_intensity operations.\nunique_contexts::Vector{Symbol}: List of unique symbols extracted from Trace objects.\ncontents::Vector{<:Trace}: List of traces in long-term memory.\n\nConstructor\n\nLongTermMemory(trace_vec::Vector{<:Trace}, A_c::Float64)\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.SemanticMemory","page":"Structures","title":"HyGene.SemanticMemory","text":"SemanticMemory <: MemoryStore\n\nA memory store consisting of Trace objects. All of the items in SemanticMemory are exemplars derived from multiple observations of individual events in LongTermMemory. For example, in a LongTermMemory store with 10 separate traces with label :event_a and 10 separate traces with label :event_b, SemanticMemorywould be populated with two separate traces for:eventaand:eventb` with their item vectors being the means of the contents of the 10 separate traces for each event.\n\nParameters\n\nn_items::Integer: The number of unique exemplars, or semantic memory traces.\ncontent_labels::Vector{Symbol}: List of the labels for the unique exemplars.\ncontents::Vector{<:Trace}: List of unique exemplars in semantic memory.\nA_c::Float64: Activation threshold for condition retrieval/probability. Not typically used in these simulations.\n\nConstructor\n\nSemanticMemory(ltm::LongTermMemory)\n\n\n\n\n\n","category":"type"},{"location":"structs.html#HyGene.SetofContenders","page":"Structures","title":"HyGene.SetofContenders","text":"SetofContenders <: MemoryStore\n\nAn analog to the \"Working Memory\" concept in Thomas et al.'s (2008) [1] original HyGene paper. The SetofContenders object is used to hold above-threshold traces from SemanticMemory when an outward observation (ObsTrace) is compared against its contents. The contents of the SetofContenders is then used to compute the probability that a given semantic representation is the correct exemplar, given the probe (cond_echo_intensity).\n\nParameters\n\nn_contenders::Integer:\ncontenders::Vector{<:MemoryTrace}:\nact_min::Float64:\nt_max::Integer:\nt::Integer:\n\nConstructor\n\nSetofContenders(t_max::Integer)\n\n\n\n\n\n","category":"type"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package simulates the HyGene (Hypothesis Generation) cognitive model. HyGene is suited for simulating memory-based decisions in the face of experience (\"traces\") and current information (\"observations\"). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code is based off of Thomas et al.'s [1] original and subsequent [2] papers, which itself is influenced by Hintzman's MINERVA2 architecture [3] [4] [5].","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"HyGene.jl is not yet available via the Julia package manager. For now, you will need to: ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Clone the repository from Github, \nCreate a new .jl file in the ./model/ directory, and \nInstantiate the package from the source code.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"At the top of your new file, add the following code at the top of the page:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"cd(@__DIR__)\nusing Pkg \nPkg.activate(\"..\")\nusing HypothesisGeneration","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"After this, you may add code to build a new HyGene model.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nEasier implementations will be added later on.","category":"page"},{"location":"index.html#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The example below will show how to accomplish some basic tasks:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Build a HyGeneModel object with 4 hypotheses, each with 5 observations and each observation containing 2 contexts,\nCreate an outward observation based on the first (focal) prototype with the proportion of shared elements being 0.9, \n\"Bounce\" the observation off of long-term memory to create conditional echo content, and\nDetermine the most likely hypothesis using the Set of Contenders.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# Setting seed to replicate results\nusing HypothesisGeneration, Random\nRandom.seed!(10)\n\n# Create new HyGeneModel object\nn_contexts = 2; n_hypotheses = 4; n_obs_per_hyp = 5;\nnew_mod = HyGeneModel(n_contexts, n_hypotheses, n_obs_per_hyp);\n\n# Create observation with 0.9 fidelity (d_obs_sim)\nd_obs_sim = 0.9;\nobs = create_observation(new_mod.prototypes[1], d_obs_sim);\n\n# Generate conditional echo content\necho = echo_content(obs, new_mod.long_term_memory);\n\n# Find the best-fitting hypothesis in semantic memory\n# Get the \"winning\" trace, label, and accuracy\npopulate_soc!(echo, new_mod);\nwinner_trace, winner, acc = soc_winner(new_mod);","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"When we look at the winner, we can see that the model found the correct hypothesis, i.e., :hypothesis_1:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> winner\n:hypothesis_1","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can further probe the strength of this decision by looking at elements of the SetofContenders. For example, if we type new_mod.working_memory.n_contenders in the terminal, we will we see that the model only found one (1) contender before terminating search. Additionally, we can find the activation of the hypothesis given the echo by typing in new_mod.working_memory.act_min, which is around 0.358.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The body of the documentation describes further functionality and boundaries on them. In the above example, we would not be able to calculate the posterior probability of the contender in the SetofContenders:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> soc_posterior_prob(new_mod)\n┌ Warning: There is only 1 contender in the SoC; thus, the probability will always be 1.0.\n└ @ HyGene d:\\Documents\\GitHub\\HyGene.jl\\src\\utilities.jl:685\n1-element Vector{Float64}:\n 1.0","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As you can see by the error message, if there is only one contender in the SetofContenders, such as in our example, then the posterior probability calculation does not work and defaults to 1.0.","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1]: Thomas, R. P., Dougherty, M. R., Sprenger, A. M., & Harbison, J. (2008). Diagnostic hypothesis generation and human judgment. Psychological Review, 115(1), 155-185. https://psycnet.apa.org/doi/10.1037/0033-295X.115.1.155","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2]: Thomas, R., Dougherty, M. R., & Buttaccio, D. R. (2014). Memory constraints on hypothesis generation and decision making. Current Directions in Psychological Science, 23(4), 264–270. https://doi.org/10.1177/0963721414534853 ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]: Hintzman, D. L. (1986). \"Schema abstraction\" in a multiple-trace memory model. Psychological Review, 93(4), 411-428. https://psycnet.apa.org/doi/10.1037/0033-295X.93.4.411","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]: Hintzman, D. L. (1984). MINERVA 2: A simulation model of human memory. Behavior Research Methods, Instruments, & Computers, 16(2), 96-101. https://doi.org/10.3758/BF03202365","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[5]: Hintzman, D. L. (1988). Judgments of frequency and recognition memory in a multiple-trace memory model. Psychological Review, 95(4), 528–551. https://doi.org/10.1037/0033-295X.95.4.528","category":"page"},{"location":"sim_controller.html#Simulation-Controllers","page":"Simulation Controllers","title":"Simulation Controllers","text":"","category":"section"},{"location":"sim_controller.html#Index","page":"Simulation Controllers","title":"Index","text":"","category":"section"},{"location":"sim_controller.html","page":"Simulation Controllers","title":"Simulation Controllers","text":"Pages = [\"sim_controller.md\"]","category":"page"},{"location":"sim_controller.html#Functions","page":"Simulation Controllers","title":"Functions","text":"","category":"section"},{"location":"sim_controller.html","page":"Simulation Controllers","title":"Simulation Controllers","text":"create_labels\ncreate_prototypes\ncreate_traces\ncreate_observation","category":"page"},{"location":"sim_controller.html#HyGene.create_labels","page":"Simulation Controllers","title":"HyGene.create_labels","text":"create_labels(n_labels::Integer, label::String)\n\nCreates generic labels. For use with create_prototypes.\n\nArguments\n\nn_labels::Integer: The desired number of labels to be generated.\nlabel::String: A generic label to prepend other identifying data.\n\nExample\n\njulia> create_labels(2, \"example\")\n2-element Vector{Symbol}:\n :example1\n :example2\n\n\n\n\n\n","category":"function"},{"location":"sim_controller.html#HyGene.create_prototypes","page":"Simulation Controllers","title":"HyGene.create_prototypes","text":"create_prototypes(context_labels::Vector{Symbol}, hypothesis_labels::Vector{Symbol},\n                  n_features::Integer=15, focal_sim::Number=0.0)\n\nCreates a series of prototypes. First, a focal prototype is produced. Next, alternative hypothesis prototypes are generated with the features copied from the focal prototype with probability focal_sim. Labels are added to the prototypes and constituent Context objects.\n\nArguments\n\ncontext_labels::Vector{Symbol}: A list of labels (of type Symbol) for the generated contexts within prototypes, i.e., one for each context.\nhypothesis_labels::Vector{Symbol}: A list of labels (of type Symbol) for the generated prototypes/hypotheses, i.e., one for each object.\nn_features::Integer: Number of features in each Context minivector.\nfocal_sim::Number=0.0: Degree of similarity between the focal hypothesis and alternative hypotheses. Set to no (0.0) similarity by default.\n\n\n\n\n\ncreate_prototypes(n_contexts::Integer, n_hypotheses::Integer, n_features::Integer=15, \n                focal_sim::Number=0.0)\n\nPrototype creation script in the case where labels are not given by the user. In this case, labels are automatically generated by the program and added to the hypothesis/prototype objects.\n\nArguments\n\nn_contexts::Integer: The number of Context objects within each hypothesis object.\nn_hypotheses::Integer: The number of hypotheses to be generated.\nn_features::Integer: Number of features in each Context minivector.\nfocal_sim::Number=0.0: Degree of similarity between the focal hypothesis and alternative hypotheses. Set to no (0.0) similarity by default.\n\n\n\n\n\n","category":"function"},{"location":"sim_controller.html#HyGene.create_traces","page":"Simulation Controllers","title":"HyGene.create_traces","text":"create_traces(prototypes::Vector{MemoryTrace}, n_trace_vec::Vector{<:Number},\n              encode_fidelity::Number=0.75)\n\nGenerates MemoryTrace objects to be written to LongTermMemory. Each trace  is copied from a prototype with similarity equal to encode_fidelity. The number of copies of each prototype is set by a vector of integers (n_trace_vec).\n\nArguments\n\nprototypes::Vector{MemoryTrace}: List of prototypes to be copied into LongTermMemory.\nn_trace_vec::Vector{<:Number}: A vector of numbers indicating how many times each prototype should be copied. For example, 3 prototypes could be copied with frequencies [2,4,2] each.\nencode_fidelity::Number=0.75: The degree to which traces should match their respective prototypes.\n\n\n\n\n\ncreate_traces(prototypes::Vector{MemoryTrace}, n_traces::Integer,\n              encode_fidelity::Number=0.75)\n\nGenerates MemoryTrace objects to be written to LongTermMemory. Each trace  is copied from a prototype with similarity equal to encode_fidelity. Each prototype is  copied n_traces times.\n\nArguments\n\nprototypes::Vector{MemoryTrace}: List of prototypes to be copied into LongTermMemory.\nn_traces::Number: The number of copies of each prototype.\nencode_fidelity::Number=0.75: The degree to which traces should match their respective prototypes.\n\n\n\n\n\n","category":"function"},{"location":"sim_controller.html#HyGene.create_observation","page":"Simulation Controllers","title":"HyGene.create_observation","text":"create_observation(prototype::MemoryTrace, d_obs_sim::Number=0.85)\n\nGenerates an observation from the real world, i.e., ObsTrace. Each observation  is copied from a prototype with similarity equal to d_obs_sim.\n\nArguments\n\nprototype::MemoryTrace: Prototype to be copied.\nd_obs_sim::Number=0.85: Degree to which the observation matches the prototype.\n\n\n\n\n\n","category":"function"}]
}
